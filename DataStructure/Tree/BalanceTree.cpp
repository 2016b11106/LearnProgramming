/**
 * B-树/B+树
 * author 叶晨韬
 * date 2019/5/13
 **/
#include <iostream>

/*B树是一种多路平衡查找书，它的每一个结点最多包含k个孩子，k被成为B树的阶。k的大小取决于磁盘页的大小。
一个m阶的B树具有如下几个特征：
1.根结点至少有两个子女。
2.每个中间结点都包含k-1个元素和k个孩子,其中m/2<=k<=m。
3.每一个叶子结点都包含k-1元素，其中m/2<=k<=m。
4.所有的叶子结点都位于同一层。
5.每个结点中的元素从小到大排列，结点当中k-1个元素正好是k个孩子包含的元素的值域分划。*/
#define m 20 //m阶B-树
typedef int T;
struct Node
{
    int keynum;   //结点中当前拥有的关键字的个数
    T key[m];     //关键字向量为key[1...keynum],key[0]不用
    Node *parent; //双亲结点
    Node *son[m]; //孩子指针向量
};

//基于B-树的查找算法
//在B-树t中非递归查找关键字k
//int *pos返回k在其中的位置；*p返回k所在k所在结点的双亲结点
//*p返回检索失败的叶子结点
//函数返回值：检索成功时返回找到的结点的地址，不成功时，函数返回NULL
Node *btree_search(Node *t, T k, int *pos, Node **p)
{
    Node *q;
    int i;
    *p = NULL;
    q = t; //从树根开始向下检索
    while (q)
    {
        q->key[0] = k; //设置顺序检索用的哨兵
        for (i = q->keynum; k < q->key[i]; i--)
        {                                //从后向前找第1个小于等于k的关键字
            if (i > 0 && q->key[i] == k) //查找成功，返回q及i
            {
                *pos = i;
                return q;
            }
        }
        *p = q;        //*p为q的双亲结点
        q = q->son[i]; //继续在第i棵子树上查找
    }
    return NULL; //检索失败，返回NULL
}

/*B+树是基于B-树的一种变体，有着比B-树更高的查询性能
一个m阶的B+树具有如下几个特征：
1.有k个子树的中间结点包含有k个元素(B树中是k-1个元素)，每个元素不保存数据，只用来索引，所有数据都保存在叶子结点
2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
3.所有的中间结点元素都同时存在于子结点，在子结点元素中是最大(或最小)元素

B+树的优势：
1.单一结点存储更多的元素，使得查询的IO次数更少
2.所有查询都要查找到叶子结点，查询性能稳定
3.所有叶子结点形成有序链表，便于范围查询*/
